# commands/gen.py
import sys
import os
import random
import time
from datetime import datetime
import re
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from utils.database import get_plan
from utils.bin_database import get_bin_info  # ‚Üê AGREGAR ESTA IMPORTACI√ìN

def setup_gen_command(bot):
    @bot.message_handler(commands=['gen'])
    def gen_command_slash(message):
        generate_credit_cards(bot, message)
    
    @bot.message_handler(func=lambda message: message.text and message.text.startswith('.gen '))
    def gen_command_dot(message):
        generate_credit_cards(bot, message)

def generate_credit_cards(bot, message):
    user_id = message.from_user.id
    username = message.from_user.first_name
    
    try:
        parts = message.text.split()
        if len(parts) < 2:
            bot.reply_to(message, "‚ö†Ô∏è Uso: `/gen bin|mm|aa|cvv`\nEjemplo: `/gen 434559|03|29|123`\nEjemplo: `/gen 5598880387|09|rnd|rnd` (aleatorio)\nEjemplo: `/gen 434559|x|x|xd` (aleatorio con x)", parse_mode="Markdown")
            return
        
        input_data = parts[1]
        
        # Procesar la entrada - ACEPTAR CUALQUIER FORMATO
        if '|' in input_data:
            input_parts = input_data.split('|')
            
            # Aceptar desde 1 hasta 4 partes
            if len(input_parts) == 1:
                bin_number = input_parts[0]
                mes = "rnd"
                anio = "rnd"
                cvv = "rnd"
            elif len(input_parts) == 2:
                bin_number = input_parts[0]
                mes = input_parts[1]
                anio = "rnd"
                cvv = "rnd"
            elif len(input_parts) == 3:
                bin_number = input_parts[0]
                mes = input_parts[1]
                anio = input_parts[2]
                cvv = "rnd"
            else:  # 4 o m√°s partes
                bin_number = input_parts[0]
                mes = input_parts[1]
                anio = input_parts[2]
                cvv = input_parts[3]
            
        else:
            # Formato simple: solo BIN
            bin_number = input_data
            mes = "rnd"  # mes aleatorio
            anio = "rnd"  # a√±o aleatorio  
            cvv = "rnd"  # cvv aleatorio
        
        # Verificaci√≥n M√ÅS FLEXIBLE del BIN - aceptar cualquier cosa
        clean_bin = bin_number.replace('x', '').replace('X', '').replace('rnd', '').replace('rand', '')
        
        if clean_bin and not clean_bin.isdigit():
            bot.reply_to(message, "‚ùå El BIN debe contener solo n√∫meros, 'x', 'rnd' o 'rand'")
            return
            
        if not bin_number:
            bot.reply_to(message, f"‚ùå Debes proporcionar un BIN")
            return
        
        # Medir tiempo de generaci√≥n
        start_time = time.time()
        
        # Generar 10 tarjetas usando el algoritmo del PHP
        generated_cards = generateCC(bin_number, mes, anio, cvv, 10)
        
        # Obtener informaci√≥n del BIN para la primera tarjeta generada
        bin_info_text = get_bin_info_for_display(bin_number)
        
        # Calcular tiempo transcurrido
        end_time = time.time()
        elapsed_time = round(end_time - start_time, 2)
        
        # Obtener plan del usuario
        from utils.database import get_credits
        credits = get_credits(user_id)
        plan = get_plan(user_id, credits)
        
        # Respuesta formateada CON INFORMACI√ìN REAL DEL BIN
        response = f"""‚å¨ Bin : {bin_number}
‚å¨ Amount : 10

{generated_cards}
{bin_info_text}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚å¨ Time : {elapsed_time} sec
‚å¨ Generated By : {username} [ {plan} ]
‚å• Dev : Dunxito - üëë"""
        
        # Enviar con parse_mode Markdown para formato de c√≥digo
        bot.reply_to(message, response, parse_mode="Markdown")
        
    except Exception as e:
        bot.reply_to(message, f"‚ùå Error: {str(e)}")

def get_bin_info_for_display(bin_number):
    """Obtiene y formatea la informaci√≥n del BIN"""
    # Extraer el BIN base (primeros 6 d√≠gitos sin x)
    clean_bin = bin_number.replace('x', '').replace('X', '').replace('rnd', '').replace('rand', '')
    
    if clean_bin and len(clean_bin) >= 6:
        bin_to_check = clean_bin[:6]
    else:
        # Si no hay BIN v√°lido, usar uno por defecto
        bin_to_check = "434559"  # BIN por defecto
    
    bin_info = get_bin_info(bin_to_check)
    
    # Formatear la informaci√≥n del BIN
    return f"""‚úó Info : {bin_info.get('scheme', 'UNKNOWN')} | {bin_info.get('type', 'UNKNOWN')}
‚úó Bank : {bin_info.get('bank', 'UNKNOWN BANK')}
‚úó Country : {bin_info.get('country', 'UNKNOWN')} {bin_info.get('emoji', 'üè≥Ô∏è')}"""

# ... (el resto de las funciones se mantienen igual)

def generateCC(number, mes, anio, cvv, cantidad=10):
    """Funci√≥n principal equivalente al PHP"""
    number = checkEmpty(number)
    mes = checkEmpty(mes)
    anio = checkEmpty(anio)
    cvv = checkCVV(cvv)
    
    # Determinar tipo de tarjeta por primer d√≠gito (si existe)
    if number:
        first_digit = replaceX(number)[0] if number else '4'
        card_type = int(first_digit) if first_digit.isdigit() else 4
    else:
        card_type = 4
    
    # Longitud basada en tipo (Amex = 15, otras = 16)
    length = 15 if card_type == 3 else 16
    cvv_length = 4 if card_type == 3 else 3
    
    cc = generateCCNumbers(cantidad, number, length, cvv, cvv_length, mes, anio)
    return cc

def generateCCNumbers(cantidad, card, card_length, cvv, cvv_length, mes, anio):
    """Genera m√∫ltiples n√∫meros de tarjeta"""
    result = ''
    for i in range(cantidad):
        ccnumber = replaceX(card) if card else generateRandomBIN(card_length)
        cc = completedNumber(ccnumber, card_length)
        anioo = generateAnio(anio)
        mess = validMes(mes, anio)
        result += f"`{cc}|{mess}|{anioo}|{generateCVV(cvv_length, cvv)}`\n"
    return result

def generateRandomBIN(length):
    """Genera un BIN aleatorio si no se proporciona"""
    # Primer d√≠gito define el tipo de tarjeta
    first_digit = random.choice(['3', '4', '5', '6'])  # Amex, Visa, MC, Discover
    
    if first_digit == '3':  # Amex
        bin_length = 15
        prefix = '37' + ''.join([str(random.randint(0, 9)) for _ in range(2)])
    elif first_digit == '4':  # Visa
        bin_length = 16
        prefix = '4' + ''.join([str(random.randint(0, 9)) for _ in range(5)])
    elif first_digit == '5':  # MasterCard
        bin_length = 16
        prefix = '5' + str(random.randint(1, 5)) + ''.join([str(random.randint(0, 9)) for _ in range(4)])
    else:  # Discover
        bin_length = 16
        prefix = '6011' + ''.join([str(random.randint(0, 9)) for _ in range(2)])
    
    return prefix

def checkCVV(input_val):
    """Verifica y procesa CVV - ACEPTA rnd, rand, xd, etc."""
    if not input_val or input_val.lower() in ['rand', 'rnd', 'xd', 'random', 'x']:
        return 'xd'
    else:
        return input_val

def checkEmpty(input_val):
    """Verifica si el input est√° vac√≠o - ACEPTA rnd, rand"""
    if not input_val or input_val.lower() in ['rand', 'rnd', 'random', 'x', 'xd']:
        return None
    else:
        return input_val

def completedNumber(prefix, length):
    """Completa el n√∫mero con algoritmo Luhn"""
    if not prefix:
        prefix = generateRandomBIN(length)
    
    ccnumber = replaceX(prefix)
    
    # Asegurar longitud m√≠nima
    while len(ccnumber) < (length - 1):
        ccnumber += str(random.randint(0, 9))
    
    ccnumber = ccnumber[:length]
    
    # Algoritmo Luhn
    sum_val = 0
    pos = 0
    reversedCCnumber = ccnumber[::-1]
    
    while pos < length - 1:
        odd = int(reversedCCnumber[pos]) * 2
        if odd > 9:
            odd -= 9
        sum_val += odd
        
        if pos != (length - 2):
            sum_val += int(reversedCCnumber[pos + 1])
        
        pos += 2
    
    checkdigit = ((sum_val // 10 + 1) * 10 - sum_val) % 10
    ccnumber += str(checkdigit)
    
    return ccnumber

def generateCVV(cvv_length, cvv):
    """Genera CVV"""
    if cvv and cvv.lower() not in ['xd', 'rnd', 'rand', 'random']:
        cvv_clean = re.sub(r'\D', '', str(cvv))
        if cvv_clean:
            cvv_gen = cvv_clean
            if len(cvv_gen) < cvv_length:
                while len(cvv_gen) < cvv_length:
                    cvv_gen += str(random.randint(0, 9))
            cvv_gen = cvv_gen[:cvv_length]
        else:
            cvv_gen = ''.join([str(random.randint(0, 9)) for _ in range(cvv_length)])
    else:
        cvv_gen = ''.join([str(random.randint(0, 9)) for _ in range(cvv_length)])
    
    return cvv_gen

def generateAnio(anio):
    """Genera a√±o de expiraci√≥n - ACEPTA rnd, rand"""
    if not anio or anio.lower() in ['rand', 'rnd', 'random', 'x']:
        current_year = datetime.now().year
        anio_gen = random.randint(current_year, current_year + 10)
        return str(anio_gen)
    
    anio_clean = re.sub(r'\D', '', str(anio)) if anio else ''
    current_year = datetime.now().year
    
    if anio_clean and anio_clean.isdigit():
        if len(anio_clean) == 2:
            return "20" + anio_clean
        elif len(anio_clean) == 4:
            return anio_clean
    
    # Por defecto, a√±o aleatorio
    return str(random.randint(current_year, current_year + 10))

def validMes(mes, anio):
    """Valida y genera mes - ACEPTA rnd, rand"""
    if not mes or mes.lower() in ['rand', 'rnd', 'random', 'x']:
        anio_val = generateAnio(anio)
        current_month = datetime.now().month
        current_year = datetime.now().year
        
        if int(anio_val) == current_year:
            mes_gen = random.randint(current_month, 12)
        else:
            mes_gen = random.randint(1, 12)
        return str(mes_gen).zfill(2)
    
    mes_clean = re.sub(r'\D', '', str(mes)) if mes else ''
    anio_val = generateAnio(anio)
    
    if mes_clean and mes_clean.isdigit():
        mes_int = int(mes_clean)
        if 1 <= mes_int <= 12:
            current_month = datetime.now().month
            current_year = datetime.now().year
            
            # Validar que el mes no sea en el pasado
            if int(anio_val) == current_year and mes_int < current_month:
                mes_gen = random.randint(current_month, 12)
                return str(mes_gen).zfill(2)
            
            return str(mes_int).zfill(2)
    
    # Por defecto, mes aleatorio
    current_month = datetime.now().month
    current_year = datetime.now().year
    
    if int(anio_val) == current_year:
        mes_gen = random.randint(current_month, 12)
    else:
        mes_gen = random.randint(1, 12)
    
    return str(mes_gen).zfill(2)

def replaceX(input_val):
    """Reemplaza 'x' por n√∫meros aleatorios"""
    if not input_val:
        return ''
    
    result = ''
    for char in str(input_val):
        if char.lower() == 'x':
            result += str(random.randint(1, 9))
        else:
            result += char
    
    return result